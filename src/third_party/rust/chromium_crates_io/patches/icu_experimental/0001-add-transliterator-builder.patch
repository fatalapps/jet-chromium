From c81f1faa1c6fb3ca999ef1afb22274a37a9f4e5d Mon Sep 17 00:00:00 2001
From: Manish Goregaokar <manishearth@google.com>
Date: Mon, 2 Jun 2025 16:29:22 +0000
Subject: [PATCH] Add transliterator builder

Uplift of https://github.com/unicode-org/icu4x/pull/6658

diff --git a/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/mod.rs b/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/mod.rs
index 00ae29cd1df3d..225a0f1ec0f97 100644
--- a/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/mod.rs
+++ b/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/mod.rs
@@ -28,6 +28,8 @@ mod compile;
 #[allow(clippy::indexing_slicing, clippy::unwrap_used)] // TODO(#3958): Remove.
 mod transliterator;
 
+#[cfg(feature = "compiled_data")]
+pub use transliterator::TransliteratorBuilder;
 pub use transliterator::{CustomTransliterator, Transliterator};
 
 pub use compile::RuleCollection;
diff --git a/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/provider.rs b/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/provider.rs
index d629441570e66..6b0046718acb8 100644
--- a/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/provider.rs
+++ b/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/provider.rs
@@ -27,6 +27,9 @@ use icu_provider::prelude::*;
 use vecs::Index32;
 use zerovec::*;
 
+#[cfg(feature = "compiled_data")]
+pub use crate::provider::Baked;
+
 // TODO(#3776): Improve the documentation of this datastruct.
 
 icu_provider::data_marker!(
@@ -173,7 +176,7 @@ pub struct Rule<'a> {
 }
 
 /// The special matchers and replacers used by this transliterator.
-#[derive(Debug, Clone, zerofrom::ZeroFrom, PartialEq, Eq)]
+#[derive(Debug, Clone, zerofrom::ZeroFrom, PartialEq, Eq, Default)]
 #[cfg_attr(feature = "serde", derive(serde::Deserialize))]
 #[cfg_attr(feature = "datagen", derive(serde::Serialize, databake::Bake))]
 #[cfg_attr(feature = "datagen", databake(path = icu_experimental::transliterate::provider))]
diff --git a/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/transliterator/mod.rs b/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/transliterator/mod.rs
index debdea223490d..8200b0d542dfa 100644
--- a/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/transliterator/mod.rs
+++ b/third_party/rust/chromium_crates_io/vendor/icu_experimental-v0_3/src/transliterate/transliterator/mod.rs
@@ -180,6 +180,304 @@ pub struct Transliterator {
     env: Env,
 }
 
+/// Builder type for [`Transliterator`]
+#[derive(Debug)]
+#[cfg(feature = "compiled_data")]
+pub struct TransliteratorBuilder {
+    env: Env,
+    transliterator: DataPayload<TransliteratorRulesV1>,
+}
+
+#[cfg(feature = "compiled_data")]
+impl Default for TransliteratorBuilder {
+    fn default() -> Self {
+        Self {
+            env: LiteMap::from_iter([
+                ("any-remove".into(), InternalTransliterator::Remove),
+                ("any-null".into(), InternalTransliterator::Null),
+            ]),
+            transliterator: DataPayload::from_owned(RuleBasedTransliterator {
+                visibility: false,
+                variable_table: Default::default(),
+                filter: CodePointInversionList::all(),
+                id_group_list: Default::default(),
+                rule_group_list: Default::default(),
+            }),
+        }
+    }
+}
+
+#[cfg(feature = "compiled_data")]
+impl TransliteratorBuilder {
+    /// Creates a [`TransliteratorBuilder`] from a baked data struct.
+    ///
+    /// This method can be used to statically construct a [`Transliterator`] without including
+    /// all transliterators (which [`Transliterator::try_new`] does).
+    ///
+    /// Warning: adding additional rules after using this constructor will allocate `rules`.
+    /// If you need to add more rules, prefer using [`TransliteratorBuilder::default()`] and
+    /// [`TransliteratorBuilder::call`].
+    pub fn from_rules(rules: &'static RuleBasedTransliterator<'static>) -> Self {
+        Self {
+            transliterator: DataPayload::from_static_ref(rules),
+            ..Default::default()
+        }
+    }
+
+    /// Adds a replacement rule, replacing all strings in `matcher` by `replacer`.
+    pub fn replace(
+        mut self,
+        matcher: CodePointInversionListAndStringList<'static>,
+        replacer: String,
+    ) -> Self {
+        if matcher.size() == 0 {
+            return self;
+        }
+        self.transliterator.with_mut(move |r| {
+            let rule_group_list = r.rule_group_list.make_mut();
+
+            let mut group = if rule_group_list.is_empty() {
+                Default::default()
+            } else {
+                let g = rule_group_list
+                    .get(rule_group_list.len() - 1)
+                    .unwrap()
+                    .as_varzerovec()
+                    .into_owned();
+                rule_group_list.remove(rule_group_list.len() - 1);
+                g
+            };
+            group.make_mut().push(&Rule {
+                key: Cow::Owned(String::from(
+                    // We can just use the index in the unicode_sets list because that's the only
+                    // part of the variable table we use. If we used any of the other fields,
+                    // we'd have to update all rules that use those indices on every insertion,
+                    // as an insertion pushes the following indices up by one.
+                    char::from_u32(
+                        VarTable::BASE as u32 + r.variable_table.unicode_sets.len() as u32,
+                    )
+                    .unwrap(),
+                )),
+                replacer: Cow::Owned(replacer),
+                ante: Cow::Borrowed(""),
+                post: Cow::Borrowed(""),
+            });
+            rule_group_list.push(&group);
+
+            r.variable_table.unicode_sets.make_mut().push(&matcher);
+        });
+
+        self
+    }
+
+    /// Adds a `::NFC` rule
+    pub fn nfc(mut self, filter: CodePointInversionList<'static>) -> Self {
+        if filter.is_empty() {
+            return self;
+        }
+        self.chain(filter, Cow::Borrowed("any-nfc"));
+        self.load_nfc()
+    }
+
+    /// Adds a `::NFKC` rule
+    pub fn nfkc(mut self, filter: CodePointInversionList<'static>) -> Self {
+        if filter.is_empty() {
+            return self;
+        }
+        self.chain(filter, Cow::Borrowed("any-nfkc"));
+        self.load_nfkc()
+    }
+
+    /// Adds a `::NFD` rule
+    pub fn nfd(mut self, filter: CodePointInversionList<'static>) -> Self {
+        if filter.is_empty() {
+            return self;
+        }
+        self.chain(filter, Cow::Borrowed("any-nfd"));
+        self.load_nfd()
+    }
+
+    /// Adds a `::NFKD` rule
+    pub fn nfkd(mut self, filter: CodePointInversionList<'static>) -> Self {
+        if filter.is_empty() {
+            return self;
+        }
+        self.chain(filter, Cow::Borrowed("any-nfkd"));
+        self.load_nfkd()
+    }
+
+    /// Adds a `::Lower` rule
+    pub fn lower(mut self, filter: CodePointInversionList<'static>) -> Self {
+        if filter.is_empty() {
+            return self;
+        }
+        self.chain(filter, Cow::Borrowed("any-lower"));
+        self.load_casing()
+    }
+
+    /// Adds a `::Upper` rule
+    pub fn upper(mut self, filter: CodePointInversionList<'static>) -> Self {
+        if filter.is_empty() {
+            return self;
+        }
+        self.chain(filter, Cow::Borrowed("any-upper"));
+        self.load_casing()
+    }
+
+    /// Adds a `::Remove` rule
+    pub fn remove(mut self, filter: CodePointInversionList<'static>) -> Self {
+        if filter.is_empty() {
+            return self;
+        }
+        self.chain(filter, Cow::Borrowed("any-remove"));
+        self
+    }
+
+    /// Adds a `::Null` rule
+    pub fn null(mut self) -> Self {
+        self.transliterator.with_mut(|r| {
+            r.id_group_list
+                .make_mut()
+                .push::<&[SimpleId]>(&[].as_slice());
+
+            r.rule_group_list.make_mut().push::<&[Rule]>(&[].as_slice());
+        });
+
+        self
+    }
+
+    /// Adds a call to another transliterator
+    pub fn call(
+        mut self,
+        rules: &'static RuleBasedTransliterator<'static>,
+        filter: CodePointInversionList<'static>,
+    ) -> Self {
+        if filter.is_empty() {
+            return self;
+        }
+        let id = self.env.len().to_string();
+
+        self.env.insert(
+            id.clone(),
+            InternalTransliterator::RuleBased(DataPayload::from_static_ref(rules)),
+        );
+
+        self.chain(filter, Cow::Owned(id));
+
+        self
+    }
+
+    fn chain(&mut self, filter: CodePointInversionList<'static>, id: Cow<'static, str>) {
+        self.transliterator.with_mut(|r| {
+            r.id_group_list
+                .make_mut()
+                .push(&[SimpleId { filter, id }].as_slice());
+
+            r.rule_group_list.make_mut().push::<&[Rule]>(&[].as_slice());
+        });
+    }
+
+    /// Builds the transliterator.
+    ///
+    /// This method fails if a recursive dependency has not been loaded. Methods that add rules, such as
+    /// [`Self::nfc`] load NFC data implicitly, but if this builder was constructed with [`Self::from_rules`] or
+    /// calls a transliterator using [`Self::call`], all dependencies for the recursive transliterator need to
+    /// have been loaded.
+    pub fn build(self) -> Result<Transliterator, DataError> {
+        for dep in self.transliterator.get().deps() {
+            if !self.env.contains_key(&*dep) {
+                return Err(DataError::custom("dependency not loaded").with_display_context(&dep));
+            }
+        }
+
+        for (_, dep) in &self.env {
+            if let InternalTransliterator::RuleBased(rbt) = dep {
+                for dep in rbt.get().deps() {
+                    if !self.env.contains_key(&*dep) {
+                        return Err(
+                            DataError::custom("dependency not loaded").with_display_context(&dep)
+                        );
+                    }
+                }
+            }
+        }
+        Ok(Transliterator {
+            transliterator: self.transliterator,
+            env: self.env,
+        })
+    }
+
+    /// Loads NFC data. Call this if you load rules that use `::NFC`.
+    pub fn load_nfc(mut self) -> Self {
+        if !self.env.contains_key("any-nfc") {
+            self.env.insert(
+                String::from("any-nfc"),
+                InternalTransliterator::Composing(ComposingNormalizer::new_nfc().static_to_owned()),
+            );
+        }
+
+        self
+    }
+
+    /// Loads NFKC data. Call this if you load rules that use `::NFKC`.
+    pub fn load_nfkc(mut self) -> Self {
+        if !self.env.contains_key("any-nfkc") {
+            self.env.insert(
+                String::from("any-nfkc"),
+                InternalTransliterator::Composing(
+                    ComposingNormalizer::new_nfkc().static_to_owned(),
+                ),
+            );
+        }
+
+        self
+    }
+
+    /// Loads NFD data. Call this if you load rules that use `::NFD`.
+    pub fn load_nfd(mut self) -> Self {
+        if !self.env.contains_key("any-nfd") {
+            self.env.insert(
+                String::from("any-nfd"),
+                InternalTransliterator::Decomposing(
+                    DecomposingNormalizer::new_nfd().static_to_owned(),
+                ),
+            );
+        }
+
+        self
+    }
+
+    /// Loads NFKD data. Call this if you load rules that use `::NFKD`.
+    pub fn load_nfkd(mut self) -> Self {
+        if !self.env.contains_key("any-nfkd") {
+            self.env.insert(
+                String::from("any-nfkd"),
+                InternalTransliterator::Decomposing(
+                    DecomposingNormalizer::new_nfkd().static_to_owned(),
+                ),
+            );
+        }
+
+        self
+    }
+
+    /// Loads casing data. Call this if you load rules that use `::Lower` or `::Upper`.
+    pub fn load_casing(mut self) -> Self {
+        if !self.env.contains_key("any-lower") {
+            self.env.insert(
+                String::from("any-lower"),
+                InternalTransliterator::Lower(CaseMapper::new().static_to_owned()),
+            );
+            self.env.insert(
+                String::from("any-upper"),
+                InternalTransliterator::Upper(CaseMapper::new().static_to_owned()),
+            );
+        }
+
+        self
+    }
+}
+
 impl Transliterator {
     /// Construct a [`Transliterator`] from the given [`Locale`].
     ///
