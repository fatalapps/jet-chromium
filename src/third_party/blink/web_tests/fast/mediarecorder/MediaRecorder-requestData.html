<!DOCTYPE html>
<script src=../../resources/testharness.js></script>
<script src=../../resources/testharnessreport.js></script>
<script>

// This test verifies we can successfully create a MediaRecorder and
// get data from a MediaStream with it.

function checkStreamTracks(stream, has_video, has_audio) {
  if (has_video) {
    assert_equals(stream.getVideoTracks().length, 1);
    assert_equals(stream.getVideoTracks()[0].readyState, 'live');
  } else {
    assert_equals(stream.getVideoTracks().length, 0);
  }

  if (has_audio) {
    assert_equals(stream.getAudioTracks().length, 1);
    assert_equals(stream.getAudioTracks()[0].readyState, 'live');
  } else {
    assert_equals(stream.getAudioTracks().length, 0);
  }
};

function makeEmptyDataTest(value, expected) {
  promise_test(
      test => {
        var recorder;
        return navigator.mediaDevices.getUserMedia(value)
            .catch(test.unreached_func('Error creating MediaStream.'))
            .then(stream => {
              checkStreamTracks(stream, value['video'], value['audio']);
              recorder = new MediaRecorder(stream);
              recorder.onstop = test.unreached_func('Recording stopped.');
              recorder.onerror = test.unreached_func('Recording error.');

              // Don't wait for `onstart` before calling requestData().
              recorder.start();

              const ondataavailablePromise = new Promise(resolve => {
                recorder.ondataavailable = test.step_func(event => {
                  assert_equals(
                      event.data.size, 0, 'Recorded data size should be == 0');
                  assert_not_equals(event.timecode, NaN, 'timecode');
                  resolve();
                });
              });
              recorder.requestData();
              return ondataavailablePromise;
            });
      },
      'MediaRecorder requestData causes blobs without contained data to ' +
          `trigger ondataavailable after start (${JSON.stringify(value)})`);
}

function makeNonEmptyDataTest(value, expected) {
  promise_test(
      test => {
        var recorder;
        return navigator.mediaDevices.getUserMedia(value)
            .catch(test.unreached_func('Error creating MediaStream.'))
            .then(stream => {
              checkStreamTracks(stream, value['video'], value['audio']);
              recorder = new MediaRecorder(stream);
              recorder.onstop = test.unreached_func('Recording stopped.');
              recorder.onerror = test.unreached_func('Recording error.');

              const onstartPromise = new Promise(r => recorder.onstart = r);
              recorder.start();
              return onstartPromise
            })
            .then(() => {
              const ondataavailablePromise = new Promise(resolve => {
                recorder.ondataavailable = test.step_func(event => {
                  assert_greater_than(
                      event.data.size, 0, 'Recorded data size should be > 0');
                  assert_equals(event.data.type, value['mimeType']);
                  resolve();
                });
              });
              recorder.requestData();
              return ondataavailablePromise;
            });
      },
      'MediaRecorder requestData causes blobs with contained ' +
          `trigger ondataavailable after onstart (${JSON.stringify(value)})`);
}

generate_tests(makeEmptyDataTest,
    [["empty-video-only",
         {video: true,  audio: false, mimeType: "video/webm;codecs=vp8"}],
     ["empty-audio-only",
         {video: false, audio: true, mimeType: "audio/webm;codecs=opus"}],
     ["empty-audio-video",
         {video: true,  audio: true, mimeType: "video/webm;codecs=vp8,opus"}]]);

generate_tests(makeNonEmptyDataTest,
    [["nonempty-video-only",
         {video: true,  audio: false, mimeType: "video/webm;codecs=vp8"}],
     ["nonempty-audio-only",
         {video: false, audio: true, mimeType: "audio/webm;codecs=opus"}],
     ["nonempty-audio-video",
         {video: true,  audio: true, mimeType: "video/webm;codecs=vp8,opus"}]]);

</script>
