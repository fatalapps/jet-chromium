<!DOCTYPE html>
<html>
<head>
  <title>Test Automation Following setValueCurveAtTime Automations</title>
  <script src="../../resources/testharness.js"></script>
  <script src="../../resources/testharnessreport.js"></script>
  <script src="../resources/audit-util.js"></script>
  <script src="../resources/audio-param.js"></script>
</head>
<body>
<script>
  const sampleRate = 12800;

  // Short duration since the test doesn't require long audio
  const testDurationFrames = 256;
  const testDurationSec = testDurationFrames / sampleRate;
  const curveDuration = testDurationSec / 2;

  // Configuration for each test.
  //
  // Required options:
  //   automation - Name of automation method to test
  //   time       - Time for the automation method.
  // Optional options:
  //   extraDuration - extra time for the duration of the setValueCurve
  //                   duration.  Default is 0. This should not be on a
  //                   sample frame boundary. This is for testing that
  //                   curves that don't end on a frame boundary are handled
  //                   correctly.
  //   threshold     - Error threshold for the test; default is 0.
  const testConfigs = [
    {
      automation: 'linearRampToValueAtTime',
      time: testDurationSec,
      threshold: 3.9737e-8
    },
    {
      automation: 'linearRampToValueAtTime',
      time: testDurationSec,
      extraDuration: 0.5 / sampleRate,
      threshold: 1.8141e-8
    },
    {
      automation: 'exponentialRampToValueAtTime',
      time: testDurationSec,
      threshold: 3.9737e-8
    },
    {
      automation: 'exponentialRampToValueAtTime',
      time: testDurationSec,
      extraDuration: 0.5 / sampleRate,
      threshold: 7.8294e-8
    },
    {
      automation: 'setTargetAtTime',
      time: curveDuration,
      threshold: 1.5895e-7
    },
    {
      automation: 'setTargetAtTime',
      time: curveDuration + 0.5 / sampleRate,
      extraDuration: 0.5 / sampleRate,
      threshold: 1.3278e-7
    }
  ];

  testConfigs.forEach((config, index) => {
    const title =
        `Automation after setValueCurve: ${config.automation} ` +
            ` (config ${index + 1})`;
    promise_test(async t => {
      await runTest(config);
    }, title);
  });

  async function runTest(options) {
    // For the test, use a gain node with a constant input to test the
    // automations.
    const context = new OfflineAudioContext(1, testDurationFrames, sampleRate);

    const source = context.createBufferSource();
    source.buffer = createConstantBuffer(context, 1, 1);
    source.loop = true;

    const gain = context.createGain();

    // Any valid curve is ok.  We only use the last value for testing.
    const curve = [0, 2, 0.3];
    const actualDuration = curveDuration + (options.extraDuration || 0);
    gain.gain.setValueCurveAtTime(Float32Array.from(curve), 0, actualDuration);

    // Run the desired test automation.  The extra parameter (0.01) is only
    // used for setTargetAtTime tests; it's ignored for other tests.
    const automationValue = 2;
    gain.gain[options.automation](automationValue, options.time, 0.01);

    source.connect(gain).connect(context.destination);
    source.start();

    const resultBuffer = await context.startRendering();
    const result = resultBuffer.getChannelData(0);

    // Only need to verify that the ramp started at the right
    // value. Figure the nearest sample frame to the end curve.
    const curveEndFrame = Math.ceil(actualDuration * sampleRate);
    const curveEndTime = curveEndFrame / sampleRate;
    const finalCurveValue = curve[curve.length - 1];

    let expectedResult;
    // Determine the expected value after the end of the setValueCurve
    // event.
    if (options.automation === 'linearRampToValueAtTime') {
      expectedResult = audioParamLinearRamp(
        curveEndTime, finalCurveValue, actualDuration,
        automationValue, testDurationSec
      );
    } else if (options.automation === 'exponentialRampToValueAtTime') {
      expectedResult = audioParamExponentialRamp(
        curveEndTime, finalCurveValue, actualDuration,
        automationValue, testDurationSec
      );
    } else if (options.automation === 'setTargetAtTime') {
      expectedResult = audioParamSetTarget(
        curveEndTime, finalCurveValue, actualDuration,
        automationValue, 0.01
      );
    }

    const message =
    `After setValueCurveAtTime(..., 0, ${actualDuration}), ` +
    `${options.automation}(2, ${options.time}` +
    `${options.automation === 'setTargetAtTime' ? ', 0.01' : ''})`;

    assert_approx_equals(
      result[curveEndFrame], expectedResult,
      options.threshold || 0,
      `${message} — expected value ≈ ${expectedResult} at time ${curveEndTime}`
    );
  }

</script>
</body>
</html>
