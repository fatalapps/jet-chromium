<!DOCTYPE html>
<html>

<head>
  <title>AudioBufferSourceNode - playbackRate test</title>
  <script src="../../resources/testharness.js"></script>
  <script src="../../resources/testharnessreport.js"></script>
  <script src="../resources/audit-util.js"></script>
</head>

<body>
  <script>
    // Any sample rate mutiple of 128 is valid for this test, but here it uses
    // 48000Hz because it is a commonly used number that happens to be
    // multiple of 128.
    const sampleRate = 32768;

    // The test iterates over 60 pitches starting from 36. (MIDI pitch of C2)
    const fundamentalPitch = 36;
    const numberOfPitches = 60;

    const noteDuration = Math.floor(0.025 * sampleRate) / sampleRate;
    const totalDuration = noteDuration * numberOfPitches;

    // Test constraints for each octave.
    const testConstraints = [
      { thresholdSNR: 97.215, thresholdDiffULP: 0.6446 },
      { thresholdSNR: 97.212, thresholdDiffULP: 0.6446 },
      { thresholdSNR: 97.217, thresholdDiffULP: 0.6446 },
      { thresholdSNR: 97.196, thresholdDiffULP: 0.6485 },
      { thresholdSNR: 97.074, thresholdDiffULP: 0.6915 }
    ];

    function pitchToFrequency(midiPitch) {
      return 440 * Math.pow(2, (Math.floor(midiPitch) - 69) / 12);
    }

    function pitchDiffToPlaybackRate(midiPitchDiff) {
      return Math.pow(2, midiPitchDiff / 12);
    }

    function createSineWaveBuffer(context, frequency, duration) {
      const length = duration * sampleRate;
      const buffer = new AudioBuffer({
        numberOfChannels: 1,
        length: length,
        sampleRate: sampleRate
      });

      const data = buffer.getChannelData(0);
      const omega = 2 * Math.PI * frequency / sampleRate;
      for (let i = 0; i < data.length; i++)
        data[i] = Math.sin(omega * i);

      return buffer;
    }

    // This is the fundamental buffer for playbackRate modulation. The
    // duration of this buffer is arbitrary but long enough to produce the
    // sound without running short.
    let fundamentalBuffer;

    // A unit test consists of 2 sources: the 'actual' source runs a buffer
    // with the playback rate modulated and the 'expected' source runs a
    // mathmatically generated sound buffer.
    function runUnitTest(context, noteStart, notePitch) {
      const actualSrc = new AudioBufferSourceNode(context);
      const expectedSrc = new AudioBufferSourceNode(context);
      const merger = new ChannelMergerNode(context, { numberOfInputs: 2 });

      actualSrc.buffer = fundamentalBuffer;
      expectedSrc.buffer = createSineWaveBuffer(
          context, pitchToFrequency(notePitch), noteDuration);
      actualSrc.playbackRate.value =
          pitchDiffToPlaybackRate(notePitch - fundamentalPitch);

      actualSrc.connect(merger, 0, 0);
      expectedSrc.connect(merger, 0, 1);
      merger.connect(context.destination);

      actualSrc.start(noteStart);
      actualSrc.stop(noteStart + noteDuration);
      expectedSrc.start(noteStart);
      expectedSrc.stop(noteStart + noteDuration);
    }

    // Test if AudioBufferSourceNode.playbackRate can playback at different
    // rates properly.
    promise_test(async () => {
      const context =
          new OfflineAudioContext(2, totalDuration * sampleRate, sampleRate);
      fundamentalBuffer = createSineWaveBuffer(
          context, pitchToFrequency(fundamentalPitch), totalDuration);

      // Schedule tests up to 60 pitches above from the fundamental pitch.
      for (let iteration = 0; iteration < numberOfPitches; iteration++) {
        runUnitTest(
            context, noteDuration * iteration, fundamentalPitch + iteration);
      }

      // Once the rendering is complete, split the buffer into 5 octaves. Then
      // perform the SNR and the maximum difference ULP check for each octave
      // with different constraints.
      const renderedBuffer = await context.startRendering();
      const actual = renderedBuffer.getChannelData(0);
      const expected = renderedBuffer.getChannelData(1);
      const octaveLength = Math.floor(noteDuration * 12 * sampleRate);

      for (let i = 0; i < numberOfPitches / 12; i++) {
        const start = i * octaveLength;
        const end = (i + 1) * octaveLength;
        const octaveActual = actual.subarray(start, end);
        const octaveExpected = expected.subarray(start, end);

        compareBuffersWithConstraintsModern(
            octaveActual, octaveExpected, {
            prefix: i,
            thresholdSNR: testConstraints[i].thresholdSNR,
            thresholdDiffULP: testConstraints[i].thresholdDiffULP
        });
      }
    }, 'AudioBufferSourceNode: playbackRate should match reference sine ' +
        'wave playback across 5 octaves');
  </script>
</body>

</html>