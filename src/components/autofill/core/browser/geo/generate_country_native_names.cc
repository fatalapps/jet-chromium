// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <map>
#include <set>
#include <string>
#include <vector>

#include "base/at_exit.h"
#include "base/check.h"
#include "base/command_line.h"
#include "base/files/file_path.h"
#include "base/files/file_util.h"
#include "base/i18n/case_conversion.h"
#include "base/i18n/icu_util.h"
#include "base/i18n/unicodestring.h"
#include "base/logging.h"
#include "base/strings/utf_string_conversions.h"
#include "components/autofill/core/browser/geo/country_data.h"
#include "third_party/icu/source/common/unicode/locid.h"
#include "third_party/icu/source/common/unicode/unistr.h"

std::map<std::u16string, std::string> GenerateCountryNativeNamesMap() {
  const autofill::CountryDataMap* country_data_map =
      autofill::CountryDataMap::GetInstance();
  const std::set<std::string> autofill_country_codes(
      country_data_map->country_codes().begin(),
      country_data_map->country_codes().end());

  // Map from native name (e.g. "Deutschland") to country code (e.g. "DE").
  std::map<std::u16string, std::string> country_native_names;

  int32_t num_locales = 0;
  const icu::Locale* available_locales =
      icu::Locale::getAvailableLocales(num_locales);

  for (int32_t i = 0; i < num_locales; ++i) {
    const icu::Locale& locale = UNSAFE_BUFFERS(available_locales[i]);
    std::string country_of_locale = locale.getCountry();
    if (country_of_locale.empty() ||
        !autofill_country_codes.count(country_of_locale)) {
      continue;
    }
    icu::UnicodeString country_name_unicode;
    locale.getDisplayCountry(locale, country_name_unicode);
    std::u16string native_name = base::i18n::ToUpper(
        base::i18n::UnicodeStringToString16(country_name_unicode));

    auto [it, inserted] =
        country_native_names.try_emplace(native_name, country_of_locale);
    CHECK(inserted || it->second == country_of_locale)
        << "Native name collision for '" << base::UTF16ToUTF8(native_name)
        << "': maps to both " << it->second << " and " << country_of_locale
        << ". This probably happened due to an ICU update. Please "
           "resolve manually by adding a special case dropping one of the "
           "mappings in this function";
  }

  return country_native_names;
}

void WriteCountryNativeNamesInlFile(
    const base::FilePath& output_file_path,
    const std::map<std::u16string, std::string>& country_native_names) {
  std::string inl_file_content =
      "// Copyright 2025 The Chromium Authors\n"
      "// Use of this source code is governed by a BSD-style license that can "
      "be\n"
      "// found in the LICENSE file.\n\n"
      "#ifndef "
      "COMPONENTS_AUTOFILL_CORE_BROWSER_GEO_COUNTRY_NATIVE_NAMES_INL_H_\n"
      "#define "
      "COMPONENTS_AUTOFILL_CORE_BROWSER_GEO_COUNTRY_NATIVE_NAMES_INL_H_\n\n"
      "#include <string_view>\n"
      "#include \"base/containers/fixed_flat_map.h\"\n\n"
      "namespace autofill {\n\n"
      "// A map from the country name in their native language to the "
      "country code.\n"
      "// This is generated by "
      "// components/autofill/core/browser/geo/tools/"
      "generate_country_native_names.cc.\n"
      "// Do not edit manually.\n"
      "namespace {\n\n"
      "constexpr auto kCountryNativeNames = "
      "base::MakeFixedFlatMap<std::u16string_view, "
      "std::string>({\n";

  for (const auto& [native_name, country_code] : country_native_names) {
    inl_file_content += "    {u\"" + base::UTF16ToUTF8(native_name) + "\", \"" +
                        country_code + "\"},\n";
  }

  inl_file_content +=
      "  });\n\n"
      "}  // namespace\n\n"
      "}  // namespace autofill\n\n"
      "#endif  // "
      "COMPONENTS_AUTOFILL_CORE_BROWSER_GEO_COUNTRY_NATIVE_NAMES_INL_H_\n";

  CHECK(base::CreateDirectory(output_file_path.DirName()));
  CHECK(base::WriteFile(output_file_path, inl_file_content));
}

int main(int argc, char* argv[]) {
  base::AtExitManager exit_manager;
  base::CommandLine::Init(argc, argv);
  base::FilePath output_file_path =
      base::CommandLine::ForCurrentProcess()->GetSwitchValuePath(
          "output-file-path");
  CHECK(!output_file_path.empty());
  base::i18n::InitializeICU();
  WriteCountryNativeNamesInlFile(output_file_path,
                                 GenerateCountryNativeNamesMap());
  return 0;
}
